/**************** MIXINS ****************/

@mixin fsize-pad($size, $pad:null) {
    @if $size { font-size: $size; }
    @if $pad { padding: $pad; }
}
@mixin colors($foreG, $backG:null) {
    @if $foreG { color: $foreG; }
    @if $backG { background-color: $backG; }
}
@mixin flex-fam($dir:null, $just:null, $align:null, $wrap:null, $flow:null) {
    @if $dir { flex-direction:$dir; }
    @if $just { justify-content: $just; }
    @if $align { align-items: $align; }
    @if $wrap { flex-wrap:$wrap; }
    @if $flow { flex-flow:$flow; }
}
@mixin column-size($width, $margin:null) {
    @if $width { width: $width; }
    @if $margin { margin: $margin; }
    @else { margin: $col-margin; }
}
@mixin set-box-sizing($property) {
    -webkit-box-sizing: $property;
    box-sizing: $property;
}
@mixin breakpt($size) { // Media query mixin
    // Assign $gp-break to benefit any global_extend() mixins included in @content:
    $gp-break: $size !global;
    // Create media query from string mapped to $size in $media_strings:
    @media #{map-get($media_strings, $size)} {
        @content;
    }
    // Reset $gp-break to default:
    $gp-break: $gp-origin-break !global;
}
// Print @content inside placeholder class for each media query, $extends optional list of classes:
@mixin global_placehold($plac_name, $extends:null) {
    // If placeholder name is not in the list:
    @if not index($global_placeholds, $plac_name) {
        // Append placeholder name to the list:
        $global_placeholds: append($global_placeholds, $plac_name) !global;
        // Escape any selector nesting around mixin call:
        @at-root {
            // Iterate on $media_strings map - including merged default size (ie: "mobile"):
            @each $break_name, $break_string in map-merge($media_strings, ($gp-origin-break: "all")) {
                // Create media query:
                @media #{$break_string} {
                    // Create placeholder with -#{$break_name} extension (ie: "-small", "-medium", etc.):
                    %#{$plac_name}-#{$break_name} {
                        // If $extends - list of classes to extend - was passed:
                        @if $extends {
                            // For each class name:
                            @each $extend in $extends {
                                // Extend placeholder with -#{$break_name} extension:
                                @extend %#{$extend}-#{$break_name} !optional;
                            }
                        }
                        // Global placeholder class content:
                        @content;
                    }
                }
            }
        }
    }
}
@mixin global_extend($plac_name) {
    // Extend placeholder name with -#{$gp-break} extension (ie: "-small", "-medium", etc.):
    @extend %#{$plac_name}-#{$gp-break} !optional;
}
@function build_media_strings() { // Construct media query strings from $breaks map
    $media_strings: (); // Map to return
    $break_num: 1; // Iteration count
    @each $break_name, $size in $breaks { // For each $name:$size pair
        @if 1 < $break_num and $break_num < length($breaks) { // Excluding the first and last
            $next_size: nth(nth($breaks, $break_num + 1), 2); // Get $size of following breakpoint
            // Create new map value ($breakpoint_name:"media query string"):
            $new_media: ($break_name: 'all and (min-width:' + ($size + 1) + ') and (max-width:' + $next_size + ')');
            $media_strings: map-merge($media_strings, $new_media); // Append new map to return values
        }
        @if $break_num == length($breaks) { // If this is the last $name:$size pair
            $new_media: ($break_name: 'all and (min-width:' + $size + ')'); // There is no max-width
            $media_strings: map-merge($media_strings, $new_media);
        }
        $break_num: $break_num + 1;
    }
    @return $media_strings;
}

